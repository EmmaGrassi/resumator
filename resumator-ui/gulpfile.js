// Node libraries
var fs = require('fs');

// Gulp system
var gulp = require('gulp');
var plugins = require('gulp-load-plugins')();
var gulpHelp = require('gulp-help');
var gutil = require('gulp-util');
gulp = gulpHelp(gulp);

// Gulp plugins
var browserify = require('browserify');
var buffer = require('vinyl-buffer');
var rimraf = require('rimraf');
var browserSync = require('browser-sync');
var pngquant = require('imagemin-pngquant');
var runSequence = require('run-sequence');
var source = require('vinyl-source-stream');
var uglify = require('gulp-uglify');
var watchify = require('watchify');
var eslint = require('gulp-eslint');
var LessPluginAutoPrefix = require('less-plugin-autoprefix');
var autoprefix = new LessPluginAutoPrefix({ browsers: ['last 2 versions'] });

// Error handling
function handleError(taskName, _error) {
  const error = error.message && error.stack && error.message + '\n\n' + error.stack || error.message || error.stack || error;

  gutil.log(error);
}

// Browserify
function getBundle(path) {
  return browserify({
    entries: path,
    // TODO: Find a good way not to do this in production.
    debug: true,
    transform: [],
  });
}
function runBundle() {
  return function(bundle, cb) {
    bundle
      .bundle()
      .on('error', function (error) {
        console.error(error.stack || error.message || error);
        this.emit('end');
      })
      .pipe(source('app.bundle.js'))
      .pipe(gulp.dest('build/js'))
      .on('end', cb)
      .pipe(browserSync.reload({
        stream:true
      }));
  };
}

gulp.task('cleanDirectory', 'Cleans the build directory, starting every run with a clean slate.', function(cb) {
  rimraf('build/*', cb);
});

gulp.task('compileBabel', 'Compiles all JavaScript files from ES2015 to ES5 with Babel.js from the source directory to the build directory.', function(cb) {
  return gulp.src('src/**/*.js')
    .pipe(plugins.plumber({
      errorHandler: function(error) {
        console.log(error);
        this.emit('end');
      }
    }))
    .pipe(plugins.changed('build'))
    // TODO: Doesn't work.
    .pipe(plugins.sourcemaps.init())
    .pipe(plugins.babel({
      presets: [ 'es2015', 'react', 'stage-0' ]
    }))
    .pipe(plugins.sourcemaps.write())
    .pipe(gulp.dest('build'))
});

gulp.task('compileBrowserify', 'Compiles the client JavaScript code from the build directory into one file in the build directory with Browserify.', function compileBrowserify(cb) {
  var path = 'build/js/app.js';

  fs.exists(path, function(doesExist) {
    if (!doesExist) {
      return cb();
    }

    var bundle = getBundle(path);

    runBundle()(bundle, function(error) {
      if (error) {
        return cb(error);
      }

      cb();
    });
  });
});

gulp.task('compileImages', 'Minifies all GIF, JPG, PNG and SVG images from the source directory into the build directory.', function compileImages() {
  return gulp.src('src/**/*.@(gif|jpg|png|svg)')
    .pipe(plugins.changed('build'))
    .pipe(plugins.imagemin({
      progressive: true,
      svgoPlugins: [ { removeViewbox: false } ],
      use: [ pngquant() ]
    }))
    .pipe(gulp.dest('build'))
    .pipe(browserSync.reload({
      stream:true
    }));
});

gulp.task('compileLess', 'Compiles all LESS files to CSS from the source directory to the build directory.', function compileLess() {
  return gulp.src('src/styles/app.less')
    .pipe(plugins.changed('build'))
    .pipe(plugins.less({
      plugins: [autoprefix]
    }))
    .pipe(plugins.cssnano())
    .pipe(gulp.dest('build/css'))
    .pipe(browserSync.reload({
      stream:true
    }));
});

gulp.task('compileCopy', 'Copies over all files that are not compiled by another task from the source directory to the build directory.', function compileCopy() {
  return gulp.src('src/**/*.!(gif|jpg|png|svg|less|js)')
    .pipe(plugins.changed('build'))
    .pipe(gulp.dest('build'))
    .pipe(browserSync.reload({
      stream:true
    }));
});

gulp.task('minifyJavaScript', 'Minifies the client javascript bundle generated by Browserify.', function minifyJavaScript() {
  return gulp.src('build/js/app.bundle.js')
    .pipe(uglify())
    .pipe(gulp.dest('build/js'));
});

gulp.task('minifyHTML', 'Minifies all HTML files and puts them in the build directory.', function minifyHTML() {
  return gulp.src('build/**/*.html')
    .pipe(plugins.htmlmin({
      removeComments: true,
      removeCommentsFromCDATA: true,
      removeCDATASectionsFromCDATA: true,
      removeAttributeQuotes: true,
      removeRedundantAttributes: true,
      useShortDoctype: true,
      collapseWhitespace: true
    }))
    .pipe(gulp.dest('build'));
});

gulp.task('modifyIndexHTML', 'Modifies the index.html so some things are not loaded in production.', function modifyIndexHTML(cb) {
  fs.readFile('build/index.html', function(error, content) {
    if (error) {
      return cb(error);
    }

    const newContent = content.toString().replace('var NODE_ENV = \'development\';', 'var NODE_ENV = \'production\';');

    fs.writeFile('build/index.html', newContent, function(error) {
      if (error) {
        return cb(error);
      }

      cb();
    });
  });
});


// TODO: Allow a way to use this HTTP server to serve the frontend and also
// proxy any requests that are not static files to a configured API server.
gulp.task('runBrowsersyncServer', 'Runs a `live-server` HTTP server, serving all of the client side files from the build directory.', function runBrowsersyncServer(cb) {
  browserSync();

  cb();
});

gulp.task('runTests', 'Runs all tests from the source directory with Mocha.', function runTests() {
  return gulp.src('test/**/*.js', { read: false })
    .pipe(plugins.mocha({
      recursive: true,
      reporter: 'spec'
    }));
});

gulp.task('watchBrowserify', 'Watches the build directory for new files that get compiled to there and re-compiles the client code with browserify when that happens.', function watchBrowserify(cb) {
  var path = 'build/js/app.js';

  fs.exists(path, function(doesExist) {
    if (!doesExist) {
      return cb();
    }

    var bundle = watchify(getBundle(path));

    bundle.on('update', function() {
      runBundle()(bundle, function() {});
    });

    bundle.on('log', gutil.log);

    runBundle()(bundle, function() {});

    cb();
  });
});

gulp.task('watchCompilers', 'Watches the source directory and runs compile tasks when changes happen.', function watchCompilers(cb) {
  plugins.saneWatch('src/**/*', { debounce: 300 }, function(filename, path, stat) {
    if (filename.match(/^.*\.js$/)) {
      gulp.start('compileBabel');
    }

    if (filename.match(/^.*\.less$/)) {
      gulp.start('compileLess');
    }

    if (filename.match(/^.*\.(gif|jpg|png|svg)$/)) {
      gulp.start('compileImages');
    }

    if (!filename.match(/^.*\.(gif|jpg|png|svg|less|js)$/)) {
      gulp.start('compileCopy');
    }
  });

  cb();
});

gulp.task('watchTests', 'Watches the source tests directory and re-runs tests when changes happen.', function watchTests(cb) {
  gulp.watch('test/**/*.js', [ 'runTests' ]);

  cb();
});

gulp.task('lint', 'Lints all the Javascript sources', function watchTests() {
  return gulp.src('src/js/**/*.js')
    .pipe(eslint())
    .pipe(eslint.format())
});

gulp.task('develop', 'Runs all tasks required for development.', function(cb) {
  runSequence(
    'cleanDirectory',

    [
      'lint',
      'compileBabel',
      'compileCopy',
      'compileImages',
      'compileLess'
    ],

    'runTests',

    [
      'runBrowsersyncServer',
      'watchBrowserify',
      'watchTests',
      'watchCompilers'
    ],

    cb
  );
});

gulp.task('production', 'Runs all tasks required for production.', function(cb) {
  runSequence(
    'cleanDirectory',

    [
      'lint',
      'compileBabel',
      'compileCopy',
      'compileImages',
      'compileLess'
    ],

    'compileBrowserify',
    'minifyJavaScript',

    'modifyIndexHTML',
    'minifyHTML',

    cb
  );
});
